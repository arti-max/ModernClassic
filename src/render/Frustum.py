#                               #
#   This file generated by AI   #
#                               #
import numpy as np
from ursina import camera
import math

class Frustum:
    def __init__(self):
        self.planes = np.zeros((6, 4), dtype=np.float32)  # 6 плоскостей: left, right, bottom, top, near, far
        
    def update_from_camera(self):
        """Обновить пирамиду видимости на основе текущей камеры"""
        # Получаем матрицы view и projection
        view_matrix = self._get_view_matrix()
        proj_matrix = self._get_projection_matrix() 
        
        # Комбинируем матрицы
        vp_matrix = proj_matrix @ view_matrix
        
        # Извлекаем плоскости из комбинированной матрицы
        self._extract_planes(vp_matrix)
    
    def _get_view_matrix(self):
        """Получить матрицу вида из камеры Ursina"""
        pos = camera.world_position
        forward = camera.forward
        up = camera.up
        right = camera.right
        
        # Создаем матрицу вида
        view = np.array([
            [right.x, up.x, -forward.x, 0],
            [right.y, up.y, -forward.y, 0], 
            [right.z, up.z, -forward.z, 0],
            [-np.dot([right.x, right.y, right.z], [pos.x, pos.y, pos.z]),
             -np.dot([up.x, up.y, up.z], [pos.x, pos.y, pos.z]),
             np.dot([forward.x, forward.y, forward.z], [pos.x, pos.y, pos.z]), 1]
        ], dtype=np.float32)
        
        return view
    
    def _get_projection_matrix(self):
        """Получить матрицу проекции"""
        fov = math.radians(camera.fov)
        aspect = camera.aspect_ratio
        near = 0.1
        far = 1000.0
        
        f = 1.0 / math.tan(fov / 2.0)
        
        proj = np.array([
            [f/aspect, 0, 0, 0],
            [0, f, 0, 0],
            [0, 0, (far+near)/(near-far), (2*far*near)/(near-far)],
            [0, 0, -1, 0]
        ], dtype=np.float32)
        
        return proj
    
    def _extract_planes(self, vp_matrix):
        """Извлечь 6 плоскостей из матрицы view-projection"""
        m = vp_matrix
        
        # Left plane
        self.planes[0] = [m[3,0] + m[0,0], m[3,1] + m[0,1], m[3,2] + m[0,2], m[3,3] + m[0,3]]
        # Right plane  
        self.planes[1] = [m[3,0] - m[0,0], m[3,1] - m[0,1], m[3,2] - m[0,2], m[3,3] - m[0,3]]
        # Bottom plane
        self.planes[2] = [m[3,0] + m[1,0], m[3,1] + m[1,1], m[3,2] + m[1,2], m[3,3] + m[1,3]]
        # Top plane
        self.planes[3] = [m[3,0] - m[1,0], m[3,1] - m[1,1], m[3,2] - m[1,2], m[3,3] - m[1,3]]
        # Near plane
        self.planes[4] = [m[3,0] + m[2,0], m[3,1] + m[2,1], m[3,2] + m[2,2], m[3,3] + m[2,3]]
        # Far plane
        self.planes[5] = [m[3,0] - m[2,0], m[3,1] - m[2,1], m[3,2] - m[2,2], m[3,3] - m[2,3]]
        
        # Нормализуем плоскости
        for i in range(6):
            length = math.sqrt(self.planes[i][0]**2 + self.planes[i][1]**2 + self.planes[i][2]**2)
            if length > 0:
                self.planes[i] /= length
    
    def is_aabb_visible(self, min_x, min_y, min_z, max_x, max_y, max_z):
        """Проверить, видим ли AABB (ограничивающий прямоугольник)"""
        # Проверяем каждую плоскость
        for plane in self.planes:
            a, b, c, d = plane
            
            # Находим "позитивную" вершину (самую далекую от плоскости)
            px = max_x if a >= 0 else min_x
            py = max_y if b >= 0 else min_y  
            pz = max_z if c >= 0 else min_z
            
            # Если позитивная вершина за плоскостью, AABB не видим
            if a * px + b * py + c * pz + d < 0:
                return False
                
        return True
    
    def is_chunk_visible(self, chunk):
        """Проверить, видим ли чанк"""
        return self.is_aabb_visible(
            chunk.minX, chunk.minY, chunk.minZ,
            chunk.maxX, chunk.maxY, chunk.maxZ
        )
